// Generated by CoffeeScript 1.3.3

/*
 * Module dependencies.
*/


(function() {
  var app, express, findRoom, getNewPosition, getRandomPosition, http, io, newRoom, path, random, roomBroadcast, roomSend, roomUpdatePosition, rooms, routes, server, snakeBodyCollision;

  express = require('express');

  routes = require('./routes');

  http = require('http');

  path = require('path');

  app = express();

  app.configure(function() {
    app.set('port', process.env.PORT || 3000);
    app.set('views', __dirname + '/views');
    app.set('view engine', 'ejs');
    app.use(express.favicon());
    app.use(express.logger('dev'));
    app.use(express.bodyParser());
    app.use(express.methodOverride());
    app.use(app.router);
    return app.use(express["static"](path.join(__dirname, 'public')));
  });

  app.configure('development', function() {
    return app.use(express.errorHandler());
  });

  app.set('title', 'Snake Online');

  app.get('/', routes.index);

  app.get('/socket.js', function(req, res) {
    return res.redirect('/socket.io/socket.io.js');
  });

  server = http.createServer(app);

  io = require('socket.io').listen(server);

  server.listen(app.get('port'), function() {
    return console.log("Express server listening on port " + app.get('port'));
  });

  snakeBodyCollision = function(head, snakeArray) {
    var isInArray, rest, section, _i, _len;
    rest = snakeArray.slice(1);
    isInArray = false;
    for (_i = 0, _len = rest.length; _i < _len; _i++) {
      section = rest[_i];
      if (head[0] === section[0] && head[1] === section[1]) {
        isInArray = true;
      }
    }
    return isInArray;
  };

  random = function(low, high) {
    return Math.floor(Math.random() * (high - low + 1) - low);
  };

  getRandomPosition = function() {
    var x, y;
    x = random(1, 58);
    y = random(1, 38);
    return [x, y];
  };

  getNewPosition = function(player1, player2) {
    var newPosition;
    newPosition = getRandomPosition();
    if (snakeBodyCollision(newPosition, player1) && snakeBodyCollision(newPosition, player2)) {
      return getNewPosition(player1, player2);
    } else {
      return newPosition;
    }
  };

  rooms = [];

  newRoom = function(socket) {
    return rooms.push({
      player1: socket,
      player2: null,
      waiting: true,
      p1position: [],
      p2position: [],
      speed: 2
    });
  };

  findRoom = function(socket) {
    var room, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = rooms.length; _i < _len; _i++) {
      room = rooms[_i];
      if (room && room.waiting) {
        room.player2 = socket;
        room.waiting = false;
        room.player1.emit('start', {
          player1: true
        });
        room.player2.emit('start', {
          player1: false
        });
        room.player1.set('room', room);
        room.player2.set('room', room);
        break;
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  roomBroadcast = function(room, event, data) {
    if (room && room.player1 && room.player2) {
      room.player1.emit(event, data);
    }
    return room.player2.emit(event, data);
  };

  roomSend = function(room, socket, event, data) {
    if (room && room.player1 && room.player2) {
      if (room.player1 === socket) {
        return room.player2.emit(event, data);
      } else {
        return room.player1.emit(event, data);
      }
    }
  };

  roomUpdatePosition = function(room, socket, position) {
    if (room.player1 === socket) {
      return room.p2position = position;
    } else {
      return room.p1position = position;
    }
  };

  io.sockets.on('connection', function(socket) {
    socket.on('new', function(data) {
      return newRoom(socket);
    });
    socket.on('join', function(data) {
      return findRoom(socket);
    });
    socket.on('update', function(data) {
      return socket.get('room', function(err, room) {
        if (data.direction) {
          roomSend(room, socket, 'update', {
            direction: data.direction,
            position: data.position
          });
        }
        return roomUpdatePosition(room, socket, data.position);
      });
    });
    socket.on('appleEaten', function(data) {
      return socket.get('room', function(err, room) {
        var position;
        position = getNewPosition(room.p1position, room.p2position);
        room.speed += 1;
        return roomBroadcast(room, 'apple', {
          x: position[0],
          y: position[1],
          speed: room.speed
        });
      });
    });
    socket.on('gameEnd', function(data) {
      return socket.get('room', function(err, room) {
        roomSend(room, socket, 'gameEnd', {
          message: "You Win!"
        });
        socket.emit('gameEnd', {
          message: "You Lose!"
        });
        return delete rooms[rooms.indexOf(room)];
      });
    });
    return socket.on('disconnect', function(data) {
      return socket.get('room', function(err, room) {
        roomSend(room, socket, 'gameEnd', {
          message: "Player2 is leaved..."
        });
        return delete rooms[rooms.indexOf(room)];
      });
    });
  });

}).call(this);
